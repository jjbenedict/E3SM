module agi_read

  !-----------------------------------------------------------------!
  ! Module to read silver iodide from an input file in E3SM simulations
  !
  !
  !-----------------Code history------------------------------------!
  ! Authors: Luke Van Roekel
  !
  !-----------------------------------------------------------------!
  use cam_abortutils,   only: endrun
  use pio
  use cam_pio_utils, only : cam_pio_openfile
  use infnan,       only: nan, assignment(=)
  use physics_types,          only: physics_state, physics_ptend
  use physics_buffer, only: physics_buffer_desc
  use shr_kind_mod,  only: r8=>shr_kind_r8
  use shr_log_mod,   only: errMsg=>shr_log_errMsg
  use shr_const_mod, only: shr_const_rdair, shr_const_g
  use phys_control,  only: phys_getopts
  use physconst,     only: pi
  use cam_logfile,   only: iulog
  use spmd_utils,    only: masterproc
  use perf_mod,      only: t_startf, t_stopf
  use mpishorthand
  use cam_history_support, only: fillvalue
  use ppgrid,         only: pver, pcols

  implicit none

  private
  save

  ! ----------------- !
  ! Public interfaces !
  ! ----------------- !

  public :: agi_read_data_init,  & ! initializes reading of file
            agi_read_data_advance  ! advances position in agi file 
       
  integer :: ntimes
  integer :: last_index = 1
  integer :: agi_vid

  logical :: initialized = .false.

  type :: agi_emis_native_grid
     !------------------------------------------------------------------
     !"agi_emis_native_grid" is forcing from files which has to be on the
     !native grid (only in horizontal,vertical resolution may be different
     !from the model's grid resolution)
     !That is, forcing files has to be on same grid as the grid used for
     !the model run
     !------------------------------------------------------------------

     !Number of levels in the 3D forcing file
     integer                               :: lev_frc

     !Data structure to store two time samples from a file to do time interpolation in the next step
     !(pcols,lev_frc,begchunk:endchunk,2)
     real(r8), pointer, dimension(:,:,:,:) :: native_grid_flds_tslices

     !Data structure to store data after time interpolation from two time samples
     !(pcols,lev_frc,begchunk:endchunk)
     real(r8), pointer, dimension(:,:,:)   :: native_grid_flds

     !Data structure to keep track of time
     type(time_coordinate) :: time_coord

     !agi emission name
     character( len = cx)  :: agi_emis_name_ngrd


     !Level bounds read from input file
     real(r8), pointer, dimension(:,:) :: lev_bnds

     !Forcing file name
     character( len = cx)  :: input_file

     !Units of forcing data
     character( len = cs)  :: units

     !logical to control first data read
     logical               :: initialized

     !pbuf index to store read in data in pbuf
     integer               :: pbuf_ndx = -1
  end type agi_emis_native_grid
  type(agi_emis_native_grid),allocatable :: native_grid_agi(:)

contains

  subroutine agi_read_data_init(

    use cam_history,      only: addfld, add_default
    use physics_types,    only: physics_state
    use ppgrid,           only: begchunk, endchunk, pcols
    use physics_buffer,   only: physics_buffer_desc, pbuf_get_index
    use physics_types,    only: physics_state
    use physics_buffer,   only: physics_buffer_desc
    use cam_grid_support, only: cam_grid_id, cam_grid_check
    use cam_grid_support, only: cam_grid_get_dim_names
    use dyn_grid,         only: get_horiz_grid_dim_d
    use dycore,           only: dycore_is
    use cam_pio_utils,    only: cam_pio_openfile
    use pio,              only: file_desc_t, pio_nowrite, pio_closefile, pio_inq_dimid, pio_bcast_error, &
         pio_seterrorhandling, pio_noerr, pio_inquire_dimension, pio_get_att, pio_inq_varid, pio_get_var


    implicit none

    !arguments
    type(physics_state), intent(in)    :: state(begchunk:endchunk)
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)

    !local vars
    type(file_desc_t)   :: fh
    character(len=16)   :: spc_name
    character(len=cxx)  :: err_str

    integer :: ndx, istat, i, astat, m, n, mm, c
    integer :: grid_id
    integer :: dimlevid, var_id, errcode, dim1id, dim2id, dim1len, dim2len
    integer :: dimbndid, nbnd
    integer :: hdim1_d, hdim2_d    ! model grid size

    real(r8) :: dtime


    if (.not. dimnames_set) then
       grid_id = cam_grid_id('physgrid')
       if (.not. cam_grid_check(grid_id)) then
          call endrun('no "physgrid" grid:'//errmsg(__FILE__,__LINE__))
       endif
       !dim1name and dim2name are populated here with the grid dimension the model is running on (e.g. ne30, lat, lon etc.)
       !For SE grid, dim1name = dim2name = "ncol"
       !For FV grid, dim1name = lon, dim2name = lat
       call cam_grid_get_dim_names(grid_id, dim1name, dim2name)
       dimnames_set = .true.
    end if

    !--------------------------------------------------------------------------------
    ! allocate forcings type array for native grid forcing files
    !--------------------------------------------------------------------------------
    allocate( native_grid_agi, stat=astat )
    if( astat /= 0 ) then
       write(err_str,*) 'failed to allocate native_grid_agi array; error = ',astat,',',errmsg(__FILE__, __LINE__)
       call endrun(err_str)
    end if

    !-----------------------------------------------------------------------
    !       initialize variables for native grid forcing files          
    !-----------------------------------------------------------------------

    input_file     = agi_emis_data_file 

    native_grid_agi%initialized    = .false.
    dtime = -1.0_r8 ! This is the offset that gives the correct time alignment -BEH
    call native_grid_agi%time_coord%initialize(trim(adjustl(input_file)), &
               force_time_interp=.true., delta_days=dtime)

    !-----------------------------------------------------------------------
    !       Open file
    !-----------------------------------------------------------------------
    call cam_pio_openfile(fh, trim(adjustl(input_file)), PIO_NOWRITE)

   !ask PIO to return the control if it experiences an error so that we can
    !handle it explicitly in the code
    call pio_seterrorhandling(fh, pio_bcast_error)
   
    !-----------------------------------------------------------------------
    !       Sanity checks for the native grid
    !-----------------------------------------------------------------------

    !if forcing file is on a different grid than the model grid
    !(e.g. model is running on an FV grid and forcing netcdf file is on an SE grid), exit with an error
    if(pio_inq_dimid(fh, trim(adjustl(dim1name)), dim1id) /= pio_noerr) then
    !pio_inq_dimid function tries to find dim1name in file with id "fh"
    !if it can't find dim1name, it means there is a mismacth in model and netcdf
    !file grid
       call endrun('grid mismatch, failed to find '//dim1name//' dimension in file:'&
            &' '//trim(adjustl(native_grid_frc_air(m)%input_file))//' '&
            &' '//errmsg(__FILE__,__LINE__))
    endif

    !find if the model and netcdf file has same grid resolution
    call get_horiz_grid_dim_d(hdim1_d,hdim2_d) !get model dim lengths
    if( dycore_is('SE') )  then
       if(pio_inquire_dimension(fh, dim1id, len = dim1len) ==  pio_noerr) then
          if(dim1len /= hdim1_d ) then !compare model grid length with file's
             write(err_str,*)'Netcdf file grid size(',dim1len,') should be same as model grid size(',&
                  hdim1_d,'), netcdf file is:'//trim(adjustl(native_grid_frc_air(m)%input_file))
             call endrun(err_str//errmsg(__FILE__,__LINE__))
          endif
       else
          call endrun('failed while inquiring dimensions of file:'//trim(adjustl(native_grid_frc_air(m)%input_file))//' '&
               &' '//errmsg(__FILE__,__LINE__))
       endif
    elseif( dycore_is('LR')) then
       if(pio_inq_dimid(fh, trim(adjustl(dim2name)), dim2id) .ne. pio_noerr) then !obtain lat dimension of model
          call endrun('failed while inquiring dimension'//trim(adjustl(dim2name))//' from file:'&
               &' '//trim(adjustl(native_grid_frc_air(m)%input_file))//' '//errmsg(__FILE__,__LINE__))
       endif
       if(pio_inquire_dimension(fh, dim1id, len = dim1len) ==  pio_noerr .and. &
          pio_inquire_dimension(fh, dim2id, len = dim2len) ==  pio_noerr) then !compare grid and model's dims
          if(dim1len /= hdim1_d .or. dim2len /= hdim2_d)then
             write(err_str,*)'Netcdf file grid size(',dim1len,' x ',dim2len,') should be same as model grid size(',&
                   hdim1_d,' x ',hdim2_d,'), netcdf file is:'//trim(adjustl(input_file))
             call endrun(err_str//errmsg(__FILE__,__LINE__))
          endif
       else
          call endrun('failed while inquiring dimensions of file:'//trim(adjustl(input_file))//' '&
                       &' '//errmsg(__FILE__,__LINE__))
       endif
    else
       call endrun('Only SE or LR(FV) grids are supported currently:'//errmsg(__FILE__,__LINE__))
    endif

    !Find the value of vertical levels in the forcing file
    if( pio_inq_dimid(fh, 'lev', dimlevid) ==  pio_noerr ) then
       if ( pio_inquire_dimension(fh, dimlevid, len =  native_grid_agi%lev_frc) /=  pio_noerr ) then
          write(err_str,*)'failed to obtain value of "lev" dimension from file:',&
                           trim(adjustl(input_file)),',',errmsg(__FILE__, __LINE__)
          call endrun(err_str)
       endif
       !obtain level bounds needed for vertical interpolation
       if( pio_inq_varid(fh, 'lev_bnds', var_id) ==  pio_noerr ) then
          !get dimension "bound"
          if( pio_inq_dimid(fh, 'bound', dimbndid) ==  pio_noerr ) then
             if ( pio_inquire_dimension(fh, dimbndid, len = nbnd) ==  pio_noerr ) then
                !"nbnd" has to be 2 (it is obvious but adding a check here doesn't hurt)
                if(nbnd /= 2) then
                   write(err_str,*)'"bound" should be equal to 2, bound=',nbnd,' in file:', &
                                    trim(adjustl(input_file)),',',errmsg(__FILE__, __LINE__)
                   call endrun(err_str)
                endif
                allocate(native_grid_agi%lev_bnds(nbnd,native_grid_agi%lev_frc))
                if (pio_get_var(fh, var_id,native_grid_agi%lev_bnds) /=  pio_noerr ) then
                   write(err_str,*)'failed to read "lev_bnds" variable from file:',&
                                    trim(adjustl(input_file)),',',errmsg(__FILE__, __LINE__)
                   call endrun(err_str)
                endif
             else
                write(err_str,*)'failed to obtain value of "bound" dimension from file:',&
                                 trim(adjustl(input_file)),',',errmsg(__FILE__, __LINE__)
                call endrun(err_str)
             endif
          else
             write(err_str,*)'failed to inquire "bound" dimension from file:',&
                              trim(adjustl(input_file)),',',errmsg(__FILE__, __LINE__)
             call endrun(err_str)
          endif
       else
          write(err_str,*)'failed to obtain "lev_bnds" variable from file:',&
                           trim(adjustl(input_file)),',',errmsg(__FILE__, __LINE__)
          call endrun(err_str)
       endif
    else
       write(err_str,*)'Dimension "lev" is not found in:',&
                        trim(adjustl(input_file)),',',errmsg(__FILE__, __LINE__)
       call endrun(err_str)
    endif

    !close file
    call pio_closefile(fh)

    !allocate arrays to stroe data for interpolation in time
    allocate(native_grid_agi%native_grid_flds_tslices(pcols, native_grid_agi%lev_frc, &
             begchunk:endchunk,2), stat=astat )
    if( astat/= 0 ) then
       write(err_str,*) 'failed to allocate native_grid_agi%native_grid_flds_tslices array; '&
                       &'error = ',astat,',',errmsg(__FILE__, __LINE__)
       call endrun(err_str)
    endif
    !allocate arrays to hold data before the vertical interpolation
    allocate(native_grid_agi%native_grid_flds(pcols, native_grid_agi%lev_frc,begchunk:endchunk), stat=astat )
    if( astat/= 0 ) then
       write(err_str,*) 'failed to allocate native_grid_agi%native_grid_flds array; error = ',&
                         astat,',',errmsg(__FILE__, __LINE__)
       call endrun(err_str)
    endif

    !get pbuf index to store the field in pbuf
    native_grid_agi%pbuf_ndx = pbuf_get_index('AgI_emis',errcode)
    if(errcode < 0 ) then
       write(err_str,*)'failed to get pbuf index for AgI errorcode is:',errcode,',',errmsg(__FILE__, __LINE__)
       call endrun(err_str)
    endif

    call addfld( 'AgI_emis', (/ 'lev' /), 'A',  'kg/s',     &
            'Silver Iodide Emission rate ' )
    call add_default( 'AgI_emis', 1, ' ' )

    number_flds = 0
    if (associated(native_grid_agi%native_grid_flds_tslices))  number_flds = 1
    !read the forcing file once to initialize variable including time cordinate
    call advance_native_grid_data( native_grid_agi )
    native_grid_agi%initialized = .true.

    if( number_flds < 1 ) then
       if ( masterproc ) then
          write(err_str,*) 'There are no AgI emissions ',errmsg(__FILE__, __LINE__)
          call endrun(err_str)
       endif
    end if

   end subroutine agi_read_data_init

   subroutine agi_read_data_adv(state, pbuf2d)

    use perf_mod,     only: t_startf, t_stopf
    use tracer_data,  only: advance_trcdata
    use physics_types,only: physics_state
    use ppgrid,       only: begchunk, endchunk
    use ppgrid,       only: pcols, pver
    use string_utils, only: to_lower, GLC
    use cam_history,  only: outfld
    use physconst,    only: mwdry       ! molecular weight dry air ~ kg/kmole
    use physconst,    only: boltz                ! J/K/molecule
    ! C.-C. Chen
    use physics_buffer, only : physics_buffer_desc, pbuf_get_field, pbuf_get_chunk

    implicit none

    type(physics_state), intent(in)    :: state(begchunk:endchunk)
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    type(physics_buffer_desc), pointer :: pbuf_chnk(:)

    integer  :: ind, c, ncol, i, caseid, m, pbuf_ndx
    real(r8) :: to_mmr(pcols,pver)
    real(r8),pointer :: tmpptr(:,:)
    character(len = cs) :: units_spc

    call t_startf('agi_read_data_adv')

    units_spc = native_grid_agi%units
    pbuf_ndx = native_grid_agi%pbuf_ndx

    call advance_native_grid_data( native_grid_agi )

    call vert_interp( state, pbuf_ndx, native_grid_agi, pbuf2d)

    caseid = huge_int
 
end module agi_read
